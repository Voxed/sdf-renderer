#pragma once

#include <string>

std::string source = R"(

#version 440

#define PI 3.1415926535897932384626433832795

layout(local_size_x = 16, local_size_y = 16 ) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

layout(location = 0) uniform float normals;
layout(location = 1) uniform float light;

precision highp float;

struct SDFInstance {
    mat4 transform;
    vec4 size;
    float dataBegin;
    float dataEnd;
};

layout(std430, binding = 1) buffer sdfInstances
{
    SDFInstance instances[];
};

layout(std430, binding = 2) buffer sdfData
{
    float data[];
};

float distToBox(vec3 pos, vec3 boxSize) {
    vec3 closestPoint = clamp(pos, -boxSize/2.0, boxSize/2.0);

    return length(closestPoint - pos);
}

float SDFvalue(SDFInstance instance, vec3 voxelr)
{
    vec3 voxel = clamp(voxelr, vec3(0), instance.size.xyz - vec3(1));

    int index = int(voxel.x + voxel.y * instance.size.x + voxel.z * instance.size.x * instance.size.y);
    float data = data[int(instance.dataBegin) + index];
    return data;
}

float mixc(float v1, float v2, float a) {

    //float a2 = 1.0 - (cos(a*PI)+1)/2.0;
    return mix(v1, v2, a);
}

float SDFdist(SDFInstance instance, vec3 ray) {
    vec3 model_space = (instance.transform*vec4(ray, 1.0)).xyz;
    float d = distToBox(model_space, instance.size.xyz);
    if(d < .1) {
        vec3 off = model_space + instance.size.xyz/2;

        vec3 dist = mod(off+0.5f, 1.0f);

        float v1 = SDFvalue(instance, floor(off + vec3(0.5, 0.5, 0.5)));
        float v2 = SDFvalue(instance, floor(off + vec3(-0.5, 0.5, 0.5)));
        float v3 = SDFvalue(instance, floor(off + vec3(0.5, -0.5, 0.5)));
        float v4 = SDFvalue(instance, floor(off + vec3(-0.5, -0.5, 0.5)));
        float v5 = SDFvalue(instance, floor(off + vec3(0.5, 0.5, -0.5)));
        float v6 = SDFvalue(instance, floor(off + vec3(-0.5, 0.5, -0.5)));
        float v7 = SDFvalue(instance, floor(off + vec3(0.5, -0.5, -0.5)));
        float v8 = SDFvalue(instance, floor(off + vec3(-0.5, -0.5, -0.5)));

        float v15 = mixc(v5, v1, dist.z);
        float v26 = mixc(v6, v2, dist.z);
        float v37 = mixc(v7, v3, dist.z);
        float v48 = mixc(v8, v4, dist.z);

        float v1537 = mixc(v37, v15, dist.y);
        float v4826 = mixc(v48, v26, dist.y);

        float v = mixc(v4826, v1537, dist.x);

        return v;
    }else{
        return d;
    }
}

float dist(vec3 p) {
    float d = 150.0f;
    for(int i =0; i < instances.length(); i++) {
        float d2 = SDFdist(instances[i], p);
        if(d2 < d) {
            d = d2;
        }
    }
    return d;
}

vec3 rayCast(vec3 ray, vec3 dir) {
    vec3 start = ray;
    float distance = 0.0f;
    while(distance < 300){
        float d = dist(ray);
        if(d < 0.1) {
            return ray;
        }else{
            distance += d;
            ray = start + distance*dir;
        }
    }
    return ray;
}

vec3 GetSurfaceNormal(vec3 p)
{
    float d0 = dist(p);
    const vec2 epsilon = vec2(.0001,0);
    vec3 d1 = vec3(
        dist(p-epsilon.xyy),
        dist(p-epsilon.yxy),
        dist(p-epsilon.yyx));
    return normalize(d0 - d1);
}

void main()
{
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dims = imageSize(img_output);
    vec2 p = vec2( pixel_coords * 2 - dims ) / dims * 32;
    vec3 color = vec3(0);
    vec3 ray = vec3(0.0, 0.0, -40.0f);
    vec3 dir = vec3(p.x/32.0,p.y/32.0,1);
    vec3 d1 = rayCast(ray, dir);

    if(d1.z < 256) {
        if(normals == 0.0f)
            imageStore(img_output, pixel_coords, vec4(vec3((d1.z-10.0)/22.0 + 1.0), 1.0));
        else if(light == 1.0f) {
            vec3 c = GetSurfaceNormal(d1.xyz);
            imageStore(img_output, pixel_coords, vec4(vec3(max(0.0, dot(c, normalize(vec3(-1,1,-1)))-0.1) + 0.1), 1.0));
        }else{
            vec3 c = GetSurfaceNormal(d1.xyz);
            imageStore(img_output, pixel_coords, vec4(c, 1.0));
        }
    }else{
        imageStore(img_output, pixel_coords, vec4(vec3(0), 1.0));
    }
}

)";